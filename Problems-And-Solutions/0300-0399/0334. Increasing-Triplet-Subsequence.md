# 0324. Increasing-Triplet-Subsequence

Given an integer array  `nums`, return  `true` _if there exists a triple of indices_ `(i, j, k)` _such that_ `i < j < k` _and_ `nums[i] < nums[j] < nums[k]`. If no such indices exists, return  `false`.

**Example 1:**

**Input:** nums = [1,2,3,4,5]
**Output:** true
**Explanation:** Any triplet where i < j < k is valid.

**Example 2:**

**Input:** nums = [5,4,3,2,1]
**Output:** false
**Explanation:** No triplet exists.

**Example 3:**

**Input:** nums = [2,1,5,0,4,6]
**Output:** true
**Explanation:** One of the valid triplet is (3, 4, 5), because nums[3] == 0 < nums[4] == 4 < nums[5] == 6.

**Constraints:**

-   `1 <= nums.length <= 5 * 105`
-   `-231 <= nums[i] <= 231 - 1`

# Solution

To solve this problem, we need to keep in mind two things:

1. triplets **must** be in increasing index order
2. triplets **must** be in ascending value 

Then we can iterate over the list keeping in track 2 variables: `first` and `second` which both start as `float("inf")`.

If the element `i` is smaller or equal than `first` then `first = element i`.
If the element `i` is greater than `first` but smaller than `second` then `second = element i`.
If the element `i` is greater than `first` and `second`, we have found our increasing triplet and return `True`.

If we iterate over the list and don't find the triplet, `False` is returned.

### Python

```python
class Solution(object):
    def increasingTriplet(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """

        first = float("inf")
        second = float("inf")
        n = len(nums)

        for i in range(n):
            if nums[i] <= first:
                first = nums[i]
            elif nums[i] <= second:
                second = nums[i]
            else:
                return True

        return False
```