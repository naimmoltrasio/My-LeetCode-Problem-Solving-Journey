# 3408. Design Task Manager

There is a task management system that allows users to manage their tasks, each associated with a priority. The system should efficiently handle adding, modifying, executing, and removing tasks.

Implement the  `TaskManager`  class:

-   `TaskManager(vector<vector<int>>& tasks)`  initializes the task manager with a list of user-task-priority triples. Each element in the input list is of the form  `[userId, taskId, priority]`, which adds a task to the specified user with the given priority.
    
-   `void add(int userId, int taskId, int priority)`  adds a task with the specified  `taskId`  and  `priority`  to the user with  `userId`. It is  **guaranteed**  that  `taskId`  does not  _exist_  in the system.
    
-   `void edit(int taskId, int newPriority)`  updates the priority of the existing  `taskId`  to  `newPriority`. It is  **guaranteed**  that  `taskId`  _exists_  in the system.
    
-   `void rmv(int taskId)`  removes the task identified by  `taskId`  from the system. It is  **guaranteed**  that  `taskId`  _exists_  in the system.
    
-   `int execTop()`  executes the task with the  **highest**  priority across all users. If there are multiple tasks with the same  **highest**  priority, execute the one with the highest  `taskId`. After executing, the  `taskId`  is  **removed**  from the system. Return the  `userId`  associated with the executed task. If no tasks are available, return -1.
    

**Note**  that a user may be assigned multiple tasks.

**Example 1:**

**Input:**  
["TaskManager", "add", "edit", "execTop", "rmv", "add", "execTop"]  
[[[[1, 101, 10], [2, 102, 20], [3, 103, 15]]], [4, 104, 5], [102, 8], [], [101], [5, 105, 15], []]

**Output:**  
[null, null, null, 3, null, null, 5]

**Explanation**

TaskManager taskManager = new TaskManager([[1, 101, 10], [2, 102, 20], [3, 103, 15]]); // Initializes with three tasks for Users 1, 2, and 3.  
taskManager.add(4, 104, 5); // Adds task 104 with priority 5 for User 4.  
taskManager.edit(102, 8); // Updates priority of task 102 to 8.  
taskManager.execTop(); // return 3. Executes task 103 for User 3.  
taskManager.rmv(101); // Removes task 101 from the system.  
taskManager.add(5, 105, 15); // Adds task 105 with priority 15 for User 5.  
taskManager.execTop(); // return 5. Executes task 105 for User 5.

**Constraints:**

-   `1 <= tasks.length <= 105`
-   `0 <= userId <= 105`
-   `0 <= taskId <= 105`
-   `0 <= priority <= 109`
-   `0 <= newPriority <= 109`
-   At most  `2 * 105`  calls will be made in  **total**  to  `add`,  `edit`,  `rmv`, and  `execTop`  methods.
-   The input is generated such that  `taskId`  will be valid.

**Constraints:**

-   `1 <= s.length <= 105`
-   `s`  consists only of lowercase English letters.

# Solution

### Python

```python
import heapq
class TaskManager(object):

    def __init__(self, tasks):
        """
        :type tasks: List[List[int]]
        """
        self.task_info = {} 
        self.task_prio = [] 
        for task in tasks: 
            userId = task[0] 
            taskId = task[1] 
            priority = task[2] 
            self.add(userId, taskId, priority)


    def add(self, userId, taskId, priority):
        """
        :type userId: int
        :type taskId: int
        :type priority: int
        :rtype: None
        """
        self.task_info[taskId] = (userId, priority) 
        heapq.heappush(self.task_prio, (-priority, -taskId, -userId, taskId))
        

    def edit(self, taskId, newPriority):
        """
        :type taskId: int
        :type newPriority: int
        :rtype: None
        """
        userId, _ = self.task_info[taskId] 
        self.task_info[taskId] = (userId, newPriority)
        heapq.heappush(self.task_prio, (-newPriority, -taskId, -userId, taskId))
      

    def rmv(self, taskId):
        """
        :type taskId: int
        :rtype: None
        """
        self.task_info.pop(taskId, None)

        

    def execTop(self):
        """
        :rtype: int
        """
        heap = self.task_prio 
        
        while heap: 
            priority_neg, _, userId, taskId = heap[0] 
            if taskId not in self.task_info: 
                heapq.heappop(heap) 
                continue 
            if self.task_info[taskId][1] == -priority_neg:
                self.rmv(taskId) 
                return -userId 
            heapq.heappop(heap) 
        
        return -1
```