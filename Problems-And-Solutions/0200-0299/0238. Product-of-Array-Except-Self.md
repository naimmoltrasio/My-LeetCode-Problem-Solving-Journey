# 0238. Product of Array Except Self

Given an integer array  `nums`, return  _an array_  `answer`  _such that_  `answer[i]`  _is equal to the product of all the elements of_  `nums`  _except_  `nums[i]`.

The product of any prefix or suffix of  `nums`  is  **guaranteed**  to fit in a  **32-bit**  integer.

You must write an algorithm that runs in `O(n)` time and without using the division operation.

**Example 1:**

**Input:** nums = [1,2,3,4]
**Output:** [24,12,8,6]

**Example 2:**

**Input:** nums = [-1,1,0,-3,3]
**Output:** [0,0,9,0,0]

**Constraints:**

-   `2 <= nums.length <= 105`
-   `-30 <= nums[i] <= 30`
-   The input is generated such that  `answer[i]`  is  **guaranteed**  to fit in a  **32-bit**  integer.

# Solution

To solve this problem we obviously can't mutiply the entire array each time to calculate the $i^{th}$ position. The solution relies on calculating all the sum of products to the left and right of the array. 

Example:

If we have the array [1,2,3,4] we will calculate the left products as [1,1,2,6] and right products as [24,12,4,1]. Then, the solution for the $i^{th}$ position will be the product between the $i^{th}$ position of right and left products like: [1x24, 1x12, 2x4, 6x1] = [24,12,8,6]

### Python

```python
class Solution(object):
    def productExceptSelf(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        n = len(nums)
        left = []
        right = [0] * n   
        res = [0] * n

        for i in range(n):
            if i == 0:
                left.append(1) 
            else:
                x = left[i-1] * nums[i-1]
                left.append(x)

        for i in reversed(range(n)):
            if i == n-1:
                right[i] = 1 
            else:
                right[i] = right[i+1] * nums[i+1]

        for i in range(n):
            res[i] = left[i] * right[i]

        return res

```